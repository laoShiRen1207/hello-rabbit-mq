## RabbitMQ 分布式事务

> 简述

分布式事务指事务的操作位于不同的节点，需要保证事务的 ACID 的特性。

例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。

> 分布式事务的方式

在分布式事务中，要实现分布式事务，无外乎几种方案。

### 一、两阶段提交 

两阶段提交（two-phase-commit）2PC 需要数据库支持，java 的组件有 atomikos 等。通过引入协调者来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

1. 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
2. 如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务，否者协调者发送通知让参与者回滚事务。

需要注意的是，在准备阶段参与者执行了事务，但是还未提交，只有在提交阶段受到协调者发来的通知后，才进行提交或者回滚。

**存在的问题**

1. 2PC 是同步阻塞的，所有事务的参与者在等待其他事物响应的时候都处于同步阻塞的状态，无法进行其他操作。
2. 单点问题，事务协调者在 2PC 中起到了非常大的作用，发生故障将会造成很大影响，特别是在阶段2发生故障的时候，所有参与者会一直保持等待状态，无法完成其他操作。
3. 数据不一致，在阶段2，如果协调者只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到了消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
4. 没有完善的容错机制。

### 二、补偿事务

TCC（try-confirm-cancel）就是采用补偿机制，其核心思想是：针对每一个操作都要注册一个对应的确认和补偿（cancel）操作，根 2PC 比起来，实现以及流程相对简单一些，但数据的一致性比 2PC 差一些。他分为3个阶段。

* Try 阶段主要是对业务系统做检测及资源预留。
* Confirm 阶段主要对业务系统做确认提交，Try 阶段执行成果并开始执行 Confirm 阶段时，默认Confirm 阶段不会出错。即 只要Try 成功，Confirm 一定成功。
* Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行业务取消，预留资源释放。

**存在的问题**

在2，3不都有可能失败，TCC 属于应用层的一种补偿方式，需要程序猿在实现的时候多写很多补偿的代码。

### 三、本地消息表

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来确保在对这两个表的操作满足事务特性，并且使用了消息队列保证最终一致性。

* 在分布式事务操作的一方完成写业务数据的操作之后，向本地消息表发送一个消息，本地事务能确保这个消息一定会被写入本地消息表中，
* 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否者继续重新转发。
* 在分布式事务操作的另一方从消息队列读取一个消息，并执行消息的操作。

![](https://oscimg.oschina.net/oscnet/up-5339f0ca6af8bd6623d5257220c5f711553.JPEG)

**存在的问题**

消息表会耦合到业务系统里，如果没有封装好的解决方案，会有很多地方需要处理。

### 四、MQ  事务消息

有一些第三方的 MQ 是支持事务消息的 （RocketMQ），支持事务消息的方式也是类似于 2PC ，但是市面上一些主流的MQ 还是不支持事务消息的，比如 Kafka.

*  第一阶段 Prepared 消息，会拿到消息的地址。第二阶段执行本地事务。第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。
* 也就是说在业务方法内要想消息队列提交2次请求，一次发送消息和一次确认消息。如果确认消息发送失败了消息队列会定期扫描消息集群中的事务消息，这时候发现了 Prepare 消息，他会想消息发送者确认，所以生产方需要实现一个 check 接口，消息队列会根据发送端的设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息的发送和本地事务同时成功或同时失败。

**存在的问题**

实现难度大，主流 MQ 不支持。

 